package containers;

import java.util.ArrayList;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;

/**
 *  Срочный отказ
 *  <p>
 *  В контейнерах Java работает механизм, не позволяющий изменять их содержимое сразу нескольким процессам.
 *  Проблема возникает, если вы проводите перебор элементов контейнера, и в это время некоторый другой процесс
 *  пытается вставить, удалить или изменить один из объектов контейнера.
 *  <p>
 *  Библиотека контейнеров java поддерживает механизм «срочного отказа», который следит за тем, не было ли проведено
 *  в контейнере изменений, не относящихся к текущему процессу. Если вдруг окажется, что кто-то еще изменяет контейнер,
 *  немедленно возбуждается исключение ConcurrentModificationException. В этом и заключается принцип «срочного
 *  отказа» — механизм не пытается обнаружить проблему позднее или использовать более сложный алгоритм.
 *  <p>
 *  Увидеть действие механизма срочного отказа своими глазами довольно просто — нужно создать итератор, а затем добавить
 *  к коллекции новый элемент, поместив его в позицию, на которую указывает итератор, как в следующем примере.
 *  Здесь исключение возникает потому, что объект помещается в контейнер после того, как для этого контейнера был запрошен
 *  итератор. Возможность изменения двумя независимыми частями программы одного и того же контейнера ведет к неопределенности,
 *  поэтому исключение предупреждает вас о том, что код нужно поменять — в нашем случае надо запрашивать итератор после того,
 *  как все элементы будут добавлены в контейнер.
 *  <p>
 *  Реализации ConcurrentHashMap, CopyOnWriteArrayList и CopyOnWriteArraySet используют механизмы, предотвращающие выдачу
 *  исключения ConcurrentModificationExceptions.
 */
public class FailFast {
    public static void main(String[] args) {
        Collection<String> c = new ArrayList<String>();
        Iterator<String> it = c.iterator();
        c.add("An object");
        try {
            String s = it.next();
        } catch (ConcurrentModificationException e) {
            System.out.println(e);
        }
    }
}
